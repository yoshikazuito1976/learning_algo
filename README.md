ボゴソート：ランダムに並べ替えを行い、偶然のソートが成功した時点でソート完了。要素が増えるほど、ソート回数爆増。ギャンブル感が面白い。

2進法、n進法等の基数変換も大事。いつも飛ばしてしまうが、ひとつひとつ丁寧に見ていく。

２進法　01              110010 = 50
３進法　012               1212 = 50     
８進法　01234567            62 = 50
10進法　0123456789

基本的に10進数の数字を基数(n)で割ってその余りを並べていく流れ。10進数からn進数の場合は。

n進数から10進数の場合はどうする？ →各桁に基数の重みをかけてその和を出すと。　3進法の1212は　27＋18+3+2で50となるということ

## 論理演算、シフト演算
割り算の余りを算出　mod は%で表現

## bit列でon/off判定ができる（全検索部分和）
01の組み合わせで選択、非選択の判定ができる。Linuxのパーミッション設定と同じ
全選択になるので、20ビットが限界。PCが唸る
20ビットを超える組み合わせの場合は動的計画法をマスターしてそれを用いるのが正解
組み合わせ部分和の計算の初歩。
組み合わせをbit列で表現できることに感動。
点が線になった。
これはalgoandmath.ipynbで検証している。

## 二分探索と対数時間
二分探索はソート済みの配列という条件がつくので、まずソートしてから動かす必要があると。

これは効率はいい。でもソート済みの条件をしっかりと守ることを意識する。

## 階乗を求める（n!)
このリポジトリのipynbに記載しているが、再帰で求めるパターンとループで求めるパターンがある
ループのほうが安定してるらしい。

再帰をちゃんと使えるようになりたい。スタックのデータ構造の理解が不可欠。小さい数字（３くらい）でちょっとずつ紙に書くのがいいと思う。

読めばわかるが、まだ書けない。

再帰は終了処理を書かないと無限ループになる
ここではif n==0:return 1の部分







O記法のかっこの中身
logN≪N≪N^2≪N^3≪⋯≪2^N≪N!≪N^N


