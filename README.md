# 🧠 learning_algo – アルゴリズム学習ログ

このリポジトリは、PythonとJupyter Notebookを用いて、アルゴリズムや計算理論の基礎を学ぶ過程を記録したものです。  
単なるコード集ではなく、「理解・気づき・試行錯誤」を含む**個人の学習ログ**として運用しています。

---

## 🎯 学習の目的と背景

- 情報処理試験や教育に活かすため、アルゴリズムの基本を体系的に整理
- bit全探索や再帰、DPなどの**つまずきやすいテーマ**を自分の言葉で咀嚼
- 「教える立場」としても理解を深めるために、Notebooksでの視覚化・コメントを重視

---

## 📂 ディレクトリ構成と内容

| ファイル名 | 内容概要 |
|------------|----------|
| `BinarySearch.ipynb` | ソート済配列への二分探索（logNの理解） |
| `BitExploration.ipynb` | bit列による部分集合全探索、パーミッション類似の応用例 |
| `DP.ipynb` | 動的計画法（フィボナッチ、部分和問題など） |
| `Greedy.ipynb` | 貪欲法による簡潔な最適化 |
| `Sorts.ipynb` | バブル・選択・挿入ソートなどの比較 |
| `algoandmath.ipynb` | 学習の気づき・感動をまとめたハブノート（再帰、基数変換、O記法等） |

> ✅ ノートブックごとにMarkdownセルでコメントを加え、思考の流れも記録しています。

---

## 🚀 今後の予定（ToDo）

- [ ] DFS/BFSのグラフアルゴリズム可視化
- [ ] Topological Sortの導入
- [ ] `README_en.md`（英語版）の作成
- [ ] 各ノートに図解・手書きメモの画像挿入

---

## 💡 特筆事項（学びのハイライト）

- **bit全探索**で全組み合わせを列挙する方法を初めて理解 → 「点が線になった」感動あり
- **基数変換**の仕組みを視覚化（10進数→n進数、n進数→10進数）
- **再帰**をスタックの視点で捉え直す → 再帰終了条件の重要性を実感
- **O記法**を階層的に整理（logN ≪ N ≪ N² ≪ 2^N ≪ N!）

---

## ✅ 利用環境

- Python 3.10+
- Jupyter Notebook (VSCode or Jupyter Lab推奨)
- 推奨ライブラリ：`matplotlib`, `numpy`（必要に応じて）

---

## ⚠️ 免責・注意事項

このリポジトリは、**教育的・個人的な学習目的**で作成されたものです。  
一部の内容には間違いや未整理部分が含まれている可能性があります。コメント・Issueでのご指摘歓迎です。

---

## 👤 作者について

IT系専門学校の講師。教育・クラウド・データ分析に関心あり。  
この学習ログは「教える力」を鍛えるためのリハーサルでもあります。

---

## 📫 フィードバック歓迎！

内容についてのご意見・改善提案などありましたら、Issue や Discussions にてぜひお寄せください。



ボゴソート：ランダムに並べ替えを行い、偶然のソートが成功した時点でソート完了。要素が増えるほど、ソート回数爆増。ギャンブル感が面白い。

2進法、n進法等の基数変換も大事。いつも飛ばしてしまうが、ひとつひとつ丁寧に見ていく。

２進法　01              110010 = 50
３進法　012               1212 = 50     
８進法　01234567            62 = 50
10進法　0123456789

基本的に10進数の数字を基数(n)で割ってその余りを並べていく流れ。10進数からn進数の場合は。

n進数から10進数の場合はどうする？ →各桁に基数の重みをかけてその和を出すと。　3進法の1212は　27＋18+3+2で50となるということ

## 論理演算、シフト演算
割り算の余りを算出　mod は%で表現

## bit列でon/off判定ができる（全検索部分和）
01の組み合わせで選択、非選択の判定ができる。Linuxのパーミッション設定と同じ
全選択になるので、20ビットが限界。PCが唸る
20ビットを超える組み合わせの場合は動的計画法をマスターしてそれを用いるのが正解
組み合わせ部分和の計算の初歩。
組み合わせをbit列で表現できることに感動。
点が線になった。
これはalgoandmath.ipynbで検証している。

## 二分探索と対数時間
二分探索はソート済みの配列という条件がつくので、まずソートしてから動かす必要があると。

これは効率はいい。でもソート済みの条件をしっかりと守ることを意識する。

## 階乗を求める（n!)
このリポジトリのipynbに記載しているが、再帰で求めるパターンとループで求めるパターンがある
ループのほうが安定してるらしい。

再帰をちゃんと使えるようになりたい。スタックのデータ構造の理解が不可欠。小さい数字（３くらい）でちょっとずつ紙に書くのがいいと思う。

読めばわかるが、まだ書けない。

再帰は終了処理を書かないと無限ループになる
ここではif n==0:return 1の部分







O記法のかっこの中身
logN≪N≪N^2≪N^3≪⋯≪2^N≪N!≪N^N


